# Версионная память

## 1. Общая информация о проекте
### 1.1 Тема проекта

**Тема проекта:**
Реализация библиотеки версионных структур данных с поддержкой конкурентных независимых изменений и последующего слияния версий.

В рамках проекта реализована библиотека на языке **Go**, предоставляющая контейнеры, которые:

- допускают одновременные изменения из нескольких потоков выполнения;
- автоматически создают новые версии при первом изменении;
- поддерживают слияние независимых веток изменений;
- не требуют от пользователя явного управления версиями.

### 1.2 Требования
Реализовать структуры данных с поддержкой одновременного многопоточного независимого изменения с возможностью слияния версий.

**Основные Требования**
- Создание версии должно происходить при первом изменении без дополнительных указаний со стороны пользователя библиотеки, как если бы структура данных не была версионной.
- Должны поддерживаться такие структуры данных как множества, очереди и стеки. Способ реализации множества следует выбрать наиболее подходящим для реализации версионности.
- Отличие стека и очереди заключается в специфических операциях доступа, в соответствии с которыми должны применяться различные стратегии слияния версий.
- Демонстрация работоспособности должна быть проведена на примере добавления данных конкурентными потоками исполнения, которые со случайными интервалами генерируют данные и помещают их в структуру (можно предложить свой вариант демонстрационной задачи).

**Дополнительные требования**

- Обеспечить детерминированность алгоритма слияния. Для одной программы вне зависимости от race-conditions должны получаться одни и те же результаты.
- Поддержка сбалансированных деревьев (особенность заключается в том, что после слияния дерево должно оставаться сбалансированным).
- Разработайте механизм для определения пользовательских стратегий объединения версий.
<!-- - Реализацию дополнительного требования продемонстрируйте на примере конкурентного построения дерева частотности. -->


### 1.3 Реализованные контейнеры

В проекте реализованы следующие контейнеры:

- **Set**;
- **Stack**;
- **Queue**;
- **Balanced Tree (AVL)**

Каждый контейнер поддерживает:

- конкурентные независимые изменения;
- ветвление (`WithBranch`, `Go`);
- слияние веток (`MergeBranches`, `Join`);
- настраиваемые стратегии слияния (`Merger`).
- неявное версионирование (версии создаются автоматически при первом изменении);
- независимые источники операций (`SourceID`);
- единый механизм версионирования для разных типов контейнеров;

### 1.4 Состав команды

**Команда проекта:**
- Участник 1: @jks-sn
- Участник 2: @fatalistix

## 2. Распределение зон ответственности

Распределение ответственности в команде осуществлялось по ключевым сущностям и подсистемам проекта.

| Участник | Зона ответственности |
|--------|----------------------|
| @jks-sn | Проектирование и реализация базовых сущностей версионирования: `Operation`, `OperationID`, `SourceID`, механизм ветвления (`Fork`), идентификация источников операций |
| @fatalistix | Реализация механизма учёта изменений (`Timeline`), структуры изменений операций (`Diff`), а также стратегий слияния изменений (`Merger`) |
| @jks-sn, @fatalistix | Реализация контейнеров **Set**, **Stack** и **Queue**, включая операции, replay состояния, конкурентные сценарии и слияние веток |
| @fatalistix | Реализация сбалансированного дерева (AVL) как контейнера, включая структуру узлов, балансировку и применение операций |
| @jks-sn, @fatalistix | Разработка и поддержка тестов: функциональные тесты контейнеров, тесты слияния и конкурентные сценарии |
| @jks-sn | Подготовка и оформление документации, теоретического описания задачи и выбранного решения |

## 3. Теоретическое описание задачи и решения

### 3.1 Постановка задачи

Требуется реализовать  контейнеры, которые:

- допускают конкурентные независимые изменения;
- позволяют объединять результаты таких изменений;
- не требуют от пользователя явного управления версиями;
- сохраняют детерминированное поведение при слиянии.

### 3.2 Выбранная модель решения

В проекте используется модель **какая-то сложная модель**:

- каждое изменение контейнера представляется в виде операции (`Diff`);
- операции объединяются в упорядоченный односвязный список (`Timeline`);
- каждая ветка изменений имеет собственный источник (`SourceID`);
- ветвление реализуется через механизм отщепления ветки `Fork`;
- слияние выполняется через объединение журналов операций с учётом выбранной стратегии.
- Для обеспечения детерминированного порядка используется идентификатор операции: OperationID = (SourceID, Index)

### 3.3 Причины выбора данного подхода

#### По сравнению с глобальными блокировками
- блокировки ограничивают масштабируемость. Любая команда в любом контейнере будет требовать блокировки

#### По сравнению с копированием состояния
- копирование дорого по памяти;
- плохо масштабируется для больших структур;
- merge требует сложного сравнения состояний.

**Выбранный подход** обеспечивает:

- простоту реализации;
- детерминированное поведение;
- расширяемость;
- единый механизм для разных типов контейнеров.